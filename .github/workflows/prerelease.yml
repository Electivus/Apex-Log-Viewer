name: Pre-release (nightly)

on:
  schedule:
    # Daily at 03:00 UTC
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      label:
        description: 'Optional label for the nightly tag/title (defaults to date)'
        required: false
        type: string

concurrency:
  group: prerelease-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  check_changes:
    name: Check for changes since last pre-release
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.check.outputs.has_changes }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Detect changes since last pre-release
        id: check
        run: |
          set -euo pipefail
          # If HEAD already points at a release/pre-release tag, skip
          HEAD_SHA=$(git rev-parse HEAD)
          AT_HEAD=$(git tag --points-at "$HEAD_SHA" | grep -E '^(v[0-9]+\.[0-9]+\.[0-9]+|pre-[0-9]+\.[0-9]+\.[0-9]+)$' || true)
          if [ -n "$AT_HEAD" ]; then
            echo "HEAD already tagged: $AT_HEAD (skipping nightly)"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Consider the latest odd-minor tag (vX.Y.Z where Y is odd); fallback to legacy pre-* tags
          # grep exits 1 when no match; with pipefail that would abort the job, so tolerate empty match
          LAST_TAG=$(git tag --list 'v*' --sort=-v:refname | (grep -E '^v[0-9]+\.[0-9]*[13579]\.[0-9]+$' || true) | head -n 1)
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG=$(git tag --list 'pre-*' --sort=-v:refname | head -n 1)
          fi
          if [ -z "$LAST_TAG" ]; then
            echo "No pre-release tags found; proceeding"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "Latest pre-release tag: $LAST_TAG"
            TAG_SHA=$(git rev-list -n1 "$LAST_TAG")
            if [ "$TAG_SHA" = "$HEAD_SHA" ]; then
              echo "No changes since last pre-release"
              echo "has_changes=false" >> $GITHUB_OUTPUT
            else
              echo "Changes detected since $LAST_TAG"
              echo "has_changes=true" >> $GITHUB_OUTPUT
            fi
          fi

  build_and_test:
    name: Build and Test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: check_changes
    if: needs.check_changes.outputs.has_changes == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Node.js 20
        uses: actions/setup-node@v5
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build (type-check + lint + bundle)
        run: npm run package

      - name: Run unit tests (fast)
        run: npm run test:unit:ci

  prerelease:
    name: Create GitHub pre-release + VSIX artifact
    needs: [build_and_test, check_changes]
    if: needs.check_changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Node.js 20
        uses: actions/setup-node@v5
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build for packaging
        run: npm run package

      - name: Ensure telemetry variable present
        env:
          APPLICATIONINSIGHTS_CONNECTION_STRING: ${{ vars.APPLICATIONINSIGHTS_CONNECTION_STRING }}
        run: |
          set -euo pipefail
          if [ -z "${APPLICATIONINSIGHTS_CONNECTION_STRING:-}" ]; then
            echo "Missing APPLICATIONINSIGHTS_CONNECTION_STRING variable. Refusing to package nightly without telemetry." >&2
            exit 1
          fi

      - name: Bump version for nightly (increment from Marketplace)
        id: nightly_version
        shell: bash
        run: |
          set -euo pipefail
          BASE=$(node -p "require('./package.json').version")
          MAJOR=$(node -p "require('./package.json').version.split('.')[0]")
          MINOR=$(node -p "require('./package.json').version.split('.')[1]")
          # ensure odd minor for pre-release track
          if [ $((MINOR % 2)) -eq 0 ]; then MINOR=$((MINOR+1)); fi
          BASE_PATCH=$(node -p "require('./package.json').version.split('.')[2]")
          EXT_ID=$(node -p "require('./package.json').publisher + '.' + require('./package.json').name")
          # Export for child process (node heredoc reads process.env)
          export EXT_ID MAJOR MINOR
          echo "Looking up latest pre-release on Marketplace for $EXT_ID (major.minor ${MAJOR}.${MINOR})"
          LATEST_PATCH=$(node -e "const {spawnSync}=require('child_process');const ext=process.env.EXT_ID;const r=spawnSync('./node_modules/.bin/vsce',['show',ext,'--json'],{encoding:'utf8'});try{if(r.status!==0)throw new Error(r.stderr||String(r.status));const meta=JSON.parse(r.stdout||'{}');const versions=Array.isArray(meta.versions)?meta.versions:[];const mj=+process.env.MAJOR,mn=+process.env.MINOR;let max=-1;for(const v of versions){const pre=(v.properties||[]).some(p=>p.key==='Microsoft.VisualStudio.Code.PreRelease'&&String(p.value)==='true');const parts=String(v.version||'').split('.').map(Number);if(!pre||parts.length<3)continue;const [M,m,p]=parts;if(M===mj&&m===mn&&Number.isFinite(p)&&p>max)max=p;}process.stdout.write(max>=0?String(max):'');}catch(e){process.stdout.write('');}")
          if [ -z "${LATEST_PATCH}" ]; then LATEST_PATCH=-1; fi
          echo "Latest published pre-release patch (same MAJOR.MINOR): ${LATEST_PATCH}"
          # next patch is max(latest published, base patch) + 1
          if [ ${LATEST_PATCH} -gt ${BASE_PATCH} ]; then
            NEW_PATCH=$(( LATEST_PATCH + 1 ))
          else
            NEW_PATCH=$(( BASE_PATCH + 1 ))
          fi
          if [ $NEW_PATCH -gt 2147483647 ]; then NEW_PATCH=2147483647; fi
          NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
          echo "Nightly base=$BASE -> new version=$NEW_VERSION"
          node -e "const fs=require('fs');const p='./package.json';const j=JSON.parse(fs.readFileSync(p,'utf8'));j.version='${NEW_VERSION}';fs.writeFileSync(p,JSON.stringify(j,null,2)+'\n')"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Package VSIX (pre-release)
        env:
          APPLICATIONINSIGHTS_CONNECTION_STRING: ${{ vars.APPLICATIONINSIGHTS_CONNECTION_STRING }}
        run: npm run vsce:package:pre

      - name: Rename VSIX with timestamp
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          VERSION=$(node -p "require('./package.json').version")
          DATE=$(date -u +%Y%m%d)
          SHORTSHA=$(git rev-parse --short HEAD)
          LABEL=${{ github.event.inputs.label || '' }}
          if [ -z "$LABEL" ]; then LABEL=$DATE; fi
          FILE=$(ls *.vsix | head -n1)
          NEW_NAME="apex-log-viewer-${VERSION}-pre-${LABEL}-${SHORTSHA}.vsix"
          mv "$FILE" "$NEW_NAME"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "file=$NEW_NAME" >> $GITHUB_OUTPUT
          # Use standard v* tag, mark release as pre-release via flag
          echo "tag=v${VERSION}" >> $GITHUB_OUTPUT

      - name: Upload VSIX artifact for publish
        uses: actions/upload-artifact@v4
        with:
          name: nightly-vsix
          path: ${{ steps.meta.outputs.file }}
          if-no-files-found: error

      - name: Create or update GitHub pre-release
        env:
          TAG: ${{ steps.meta.outputs.tag }}
          VERSION: ${{ steps.meta.outputs.version }}
        run: |
          set -euo pipefail
          TITLE="$TAG"
          BODY="Automated nightly build.\n\nCommit: $GITHUB_SHA\nRun: $GITHUB_RUN_NUMBER"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Updating existing pre-release $TAG"
            gh release edit "$TAG" --title "$TITLE" --notes "$BODY" --prerelease
          else
            echo "Creating pre-release $TAG"
            gh release create "$TAG" --title "$TITLE" --notes "$BODY" --prerelease
          fi

      - name: Upload VSIX to GitHub release
        env:
          TAG: ${{ steps.meta.outputs.tag }}
          FILE: ${{ steps.meta.outputs.file }}
        run: |
          set -euo pipefail
          # Remove old asset with same name if exists
          gh release view "$TAG" --json assets --jq ".assets[].name" | grep -x "$FILE" && gh release delete-asset "$TAG" "$FILE" -y || true
          gh release upload "$TAG" "$FILE" --clobber

  marketplace:
    name: Publish to Marketplace (pre-release channel)
    if: github.repository == 'Electivus/Apex-Log-Viewer' && needs.check_changes.outputs.has_changes == 'true'
    needs: [prerelease, check_changes]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: marketplace
    env:
      VSCE_PAT: ${{ secrets.VSCE_PAT }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Setup Node.js 20
        uses: actions/setup-node@v5
        with:
          node-version: 20
          cache: npm
      - name: Install dependencies
        run: npm ci

      - name: Bump version for nightly (increment from Marketplace)
        id: nightly_version_publish
        shell: bash
        run: |
          set -euo pipefail
          BASE=$(node -p "require('./package.json').version")
          MAJOR=$(node -p "require('./package.json').version.split('.')[0]")
          MINOR=$(node -p "require('./package.json').version.split('.')[1]")
          if [ $((MINOR % 2)) -eq 0 ]; then MINOR=$((MINOR+1)); fi
          BASE_PATCH=$(node -p "require('./package.json').version.split('.')[2]")
          EXT_ID=$(node -p "require('./package.json').publisher + '.' + require('./package.json').name")
          export EXT_ID MAJOR MINOR
          LATEST_PATCH=$(node -e "const {spawnSync}=require('child_process');const ext=process.env.EXT_ID;const r=spawnSync('./node_modules/.bin/vsce',['show',ext,'--json'],{encoding:'utf8'});try{if(r.status!==0)throw new Error(r.stderr||String(r.status));const meta=JSON.parse(r.stdout||'{}');const versions=Array.isArray(meta.versions)?meta.versions:[];const mj=+process.env.MAJOR,mn=+process.env.MINOR;let max=-1;for(const v of versions){const pre=(v.properties||[]).some(p=>p.key==='Microsoft.VisualStudio.Code.PreRelease'&&String(p.value)==='true');const parts=String(v.version||'').split('.').map(Number);if(!pre||parts.length<3)continue;const [M,m,p]=parts;if(M===mj&&m===mn&&Number.isFinite(p)&&p>max)max=p;}process.stdout.write(max>=0?String(max):'');}catch(e){process.stdout.write('');}")
          if [ -z "${LATEST_PATCH}" ]; then LATEST_PATCH=-1; fi
          if [ ${LATEST_PATCH} -gt ${BASE_PATCH} ]; then
            NEW_PATCH=$(( LATEST_PATCH + 1 ))
          else
            NEW_PATCH=$(( BASE_PATCH + 1 ))
          fi
          if [ $NEW_PATCH -gt 2147483647 ]; then NEW_PATCH=2147483647; fi
          NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
          echo "Nightly base=$BASE -> new version=$NEW_VERSION"
          node -e "const fs=require('fs');const p='./package.json';const j=JSON.parse(fs.readFileSync(p,'utf8'));j.version='${NEW_VERSION}';fs.writeFileSync(p,JSON.stringify(j,null,2)+'\n')"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
      - name: Download VSIX artifact from prerelease job
        uses: actions/download-artifact@v5
        with:
          name: nightly-vsix
          path: .

      - name: Publish pre-release to Marketplace from VSIX
        run: |
          if [ -z "${VSCE_PAT}" ]; then
            echo "VSCE_PAT not set; skipping publish." && exit 0
          fi
          FILE=$(ls *.vsix | head -n1)
          if [ -z "${FILE}" ]; then
            echo "No VSIX found to publish" >&2
            exit 1
          fi
          npx --yes @vscode/vsce publish --packagePath "${FILE}" --pre-release
